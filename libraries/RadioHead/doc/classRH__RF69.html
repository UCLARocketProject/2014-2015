<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>RadioHead: RH_RF69 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RadioHead
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classRH__RF69-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RH_RF69 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transceiver.  
 <a href="classRH__RF69.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RH__RF69_8h_source.html">RH_RF69.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for RH_RF69:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classRH__RF69.png" usemap="#RH_RF69_map" alt=""/>
  <map id="RH_RF69_map" name="RH_RF69_map">
<area href="classRHSPIDriver.html" title="Base class for a RadioHead drivers that use the SPI bus to communicate with its transport hardware..." alt="RHSPIDriver" shape="rect" coords="0,56,110,80"/>
<area href="classRHGenericDriver.html" title="Abstract base class for a RadioHead driver. " alt="RHGenericDriver" shape="rect" coords="0,0,110,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRH__RF69_1_1ModemConfig.html">ModemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines register values for a set of modem configuration registers.  <a href="structRH__RF69_1_1ModemConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b7db5c6e4eb542f46fec351b2084bbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbe">ModemConfigChoice</a> { <br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea23309558997f0821df4c3f26be956937">FSK_Rb2Fd5</a> = 0, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea54ea04c0e1141d1ced103e5863965644">FSK_Rb2_4Fd4_8</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea8e4c27525b3f1456dbfb66e7d93aa6ed">FSK_Rb4_8Fd9_6</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea1a81d7fa8efafe9ecbab6123e9ceaa7a">FSK_Rb9_6Fd19_2</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea5dfccf26330be9d96bce2a1ffdb58c16">FSK_Rb19_2Fd38_4</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea195259e4a621abcc733742b51b38c672">FSK_Rb38_4Fd76_8</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea422b9a9238f51d37911c9b3b14a3ca5c">FSK_Rb57_6Fd120</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeab88d3432cd83fb07b13f993c5951bc52">FSK_Rb125Fd125</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea29c7806372c313d8a5c973b92b0de2f5">FSK_Rb250Fd250</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeaf6911ff811fb781cfa4abd5e139b0019">FSK_Rb55555Fd50</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeada06f635ace1b8b431e7ecc2a5415210">GFSK_Rb2Fd5</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeadcf4b773bd8573a20915fcfd8a5fe3d6">GFSK_Rb2_4Fd4_8</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea25d0e93fdd6986cd2e42ada7c3ceedc5">GFSK_Rb4_8Fd9_6</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6adec83fd6f777aca47298341bfc2e20">GFSK_Rb9_6Fd19_2</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea427ce920e3dcfd0e27ef4ebb7b81ab30">GFSK_Rb19_2Fd38_4</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea60fb6c655242086be1c38f663907f4f7">GFSK_Rb38_4Fd76_8</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea0d2b7d4e131c25576f552efa6ce148c4">GFSK_Rb57_6Fd120</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea20215f43ba81642933be63eaf13ba941">GFSK_Rb125Fd125</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf">GFSK_Rb250Fd250</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea752e8ffc06f2ea7280ec69839ff980ab">GFSK_Rb55555Fd50</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeab29466f7bb837092a1740e5995bcea9a">OOK_Rb1Bw1</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeafb854ba28fd990a6a770d2aa7bfcad2f">OOK_Rb1_2Bw75</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea163016ee033ce11c74d11b0c2b749a8f">OOK_Rb2_4Bw4_8</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeacd470e1fff2c7e8fb56724cd3f74e97b">OOK_Rb4_8Bw9_6</a>, 
<br />
&#160;&#160;<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea56b3342df10e7203efb04298fe989e63">OOK_Rb9_6Bw19_2</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea4cb008e46446e1397b8a72128eddff40">OOK_Rb19_2Bw38_4</a>, 
<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbeae164eaae8c1a2ca5801b4195b1f3a8e4">OOK_Rb32Bw64</a>
<br />
 }</td></tr>
<tr class="separator:a8b7db5c6e4eb542f46fec351b2084bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a7c96558708f18937bc2fa7341f217937 inherit pub_types_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> { <br />
&#160;&#160;<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937ad901fedd5b99db75c942023971632c43">RHModeInitialising</a> = 0, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHModeSleep</a>, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHModeIdle</a>, 
<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHModeTx</a>, 
<br />
&#160;&#160;<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHModeRx</a>
<br />
 }</td></tr>
<tr class="memdesc:a7c96558708f18937bc2fa7341f217937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different operating modes for the transport hardware.  <a href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">More...</a><br /></td></tr>
<tr class="separator:a7c96558708f18937bc2fa7341f217937 inherit pub_types_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9498f2f50f1fb67d4878cff56f6f2661"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9498f2f50f1fb67d4878cff56f6f2661">RH_RF69</a> (uint8_t slaveSelectPin=SS, uint8_t interruptPin=2, <a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;spi=hardware_spi)</td></tr>
<tr class="separator:a9498f2f50f1fb67d4878cff56f6f2661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d78af6f999adf187861e7e3f1d52e99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init</a> ()</td></tr>
<tr class="separator:a0d78af6f999adf187861e7e3f1d52e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864eae13e51279b9bca9de3fb2a062f9"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a864eae13e51279b9bca9de3fb2a062f9">temperatureRead</a> ()</td></tr>
<tr class="separator:a864eae13e51279b9bca9de3fb2a062f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46952d56856f22f9319fd64e3001675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#aa46952d56856f22f9319fd64e3001675">setFrequency</a> (float centre, float afcPullInRange=0.05)</td></tr>
<tr class="separator:aa46952d56856f22f9319fd64e3001675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d8979ae35033ac8bc813302e203173"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a90d8979ae35033ac8bc813302e203173">rssiRead</a> ()</td></tr>
<tr class="separator:a90d8979ae35033ac8bc813302e203173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c2d3ed4d1954a67f7cc190349b2ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a890c2d3ed4d1954a67f7cc190349b2ab">setOpMode</a> (uint8_t <a class="el" href="classRHGenericDriver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a>)</td></tr>
<tr class="separator:a890c2d3ed4d1954a67f7cc190349b2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66bfbf2057f1faeba0ad75007d623ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle</a> ()</td></tr>
<tr class="separator:af66bfbf2057f1faeba0ad75007d623ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cfebafbafc3c62dcdba7d5e2591203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a43cfebafbafc3c62dcdba7d5e2591203">setModeRx</a> ()</td></tr>
<tr class="separator:a43cfebafbafc3c62dcdba7d5e2591203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4a5d2f1847063b5f7cf6a2d14e246a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a8e4a5d2f1847063b5f7cf6a2d14e246a">setModeTx</a> ()</td></tr>
<tr class="separator:a8e4a5d2f1847063b5f7cf6a2d14e246a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dea90251531a0237c2a4f4f26d2941"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#af6dea90251531a0237c2a4f4f26d2941">setTxPower</a> (int8_t power)</td></tr>
<tr class="separator:af6dea90251531a0237c2a4f4f26d2941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1000ce6606514e9ba55c4797346ccbcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a1000ce6606514e9ba55c4797346ccbcd">setModemRegisters</a> (const <a class="el" href="structRH__RF69_1_1ModemConfig.html">ModemConfig</a> *config)</td></tr>
<tr class="separator:a1000ce6606514e9ba55c4797346ccbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9802bbdd2c814f177d6c54b28851379a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9802bbdd2c814f177d6c54b28851379a">setModemConfig</a> (<a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbe">ModemConfigChoice</a> index)</td></tr>
<tr class="separator:a9802bbdd2c814f177d6c54b28851379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2584eacf160b9d53605e82b46b6574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a6f2584eacf160b9d53605e82b46b6574">available</a> ()</td></tr>
<tr class="separator:a6f2584eacf160b9d53605e82b46b6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae298950973257e99d3e958678a26fdf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#ae298950973257e99d3e958678a26fdf2">recv</a> (uint8_t *buf, uint8_t *len)</td></tr>
<tr class="separator:ae298950973257e99d3e958678a26fdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995470e009100f30b6945747d67e9a4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a995470e009100f30b6945747d67e9a4c">send</a> (const uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:a995470e009100f30b6945747d67e9a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e72900d5511c694d8510ab60d99917d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9e72900d5511c694d8510ab60d99917d">setPreambleLength</a> (uint16_t bytes)</td></tr>
<tr class="separator:a9e72900d5511c694d8510ab60d99917d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadfa5f2783c821de73ecb09c50000d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#aeadfa5f2783c821de73ecb09c50000d4">setSyncWords</a> (const uint8_t *syncWords=NULL, uint8_t len=0)</td></tr>
<tr class="separator:aeadfa5f2783c821de73ecb09c50000d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc02a05e8f2ec61210d62fe53673ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a3dc02a05e8f2ec61210d62fe53673ca9">setEncryptionKey</a> (uint8_t *key=NULL)</td></tr>
<tr class="separator:a3dc02a05e8f2ec61210d62fe53673ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803de96f489599271790bca92ce9436e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a803de96f489599271790bca92ce9436e">getLastPreambleTime</a> ()</td></tr>
<tr class="separator:a803de96f489599271790bca92ce9436e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3285a31a83a6ab471f149efc7bbd206"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#ad3285a31a83a6ab471f149efc7bbd206">maxMessageLength</a> ()</td></tr>
<tr class="separator:ad3285a31a83a6ab471f149efc7bbd206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09f8182eea13623f2fee4059d13d6f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#aa09f8182eea13623f2fee4059d13d6f7">printRegister</a> (uint8_t reg)</td></tr>
<tr class="separator:aa09f8182eea13623f2fee4059d13d6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5be102f9291447f22b6df823455aea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#abf5be102f9291447f22b6df823455aea">printRegisters</a> ()</td></tr>
<tr class="separator:abf5be102f9291447f22b6df823455aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efc7d09d32f024ecd983c4e53e37dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a5efc7d09d32f024ecd983c4e53e37dcb">setIdleMode</a> (uint8_t idleMode)</td></tr>
<tr class="separator:a5efc7d09d32f024ecd983c4e53e37dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b91f0d505957e62bc8f7bf4167d6772"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9b91f0d505957e62bc8f7bf4167d6772">sleep</a> ()</td></tr>
<tr class="separator:a9b91f0d505957e62bc8f7bf4167d6772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRHSPIDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRHSPIDriver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRHSPIDriver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a4285d2fb96b09588556bfc4f8a143f61">RHSPIDriver</a> (uint8_t slaveSelectPin=SS, <a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;spi=hardware_spi)</td></tr>
<tr class="separator:a4285d2fb96b09588556bfc4f8a143f61 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a7ba5e6fc53e02ff8125218bc296b4557">init</a> ()</td></tr>
<tr class="separator:a7ba5e6fc53e02ff8125218bc296b4557 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">spiRead</a> (uint8_t reg)</td></tr>
<tr class="separator:a275b8c3d4d27a59d8f93a036b17bbf22 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">spiWrite</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a649210bd63262e23c9becabfc7142fd3 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#af0ffebc1db1a6008734a37c4448fe926">spiBurstRead</a> (uint8_t reg, uint8_t *dest, uint8_t len)</td></tr>
<tr class="separator:af0ffebc1db1a6008734a37c4448fe926 inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#a559b2c489825fe1ae737cb4371956d3d">spiBurstWrite</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:a559b2c489825fe1ae737cb4371956d3d inherit pub_methods_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacf1b301be4cc16800a62632df6fdd37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#aacf1b301be4cc16800a62632df6fdd37">RHGenericDriver</a> ()</td></tr>
<tr class="memdesc:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aacf1b301be4cc16800a62632df6fdd37 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf108e52389353cb3658b6802b92c77c inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf108e52389353cb3658b6802b92c77c">waitAvailable</a> ()</td></tr>
<tr class="separator:abf108e52389353cb3658b6802b92c77c inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent</a> ()</td></tr>
<tr class="separator:a7506f47e9a391ffa05f7271950c26ffe inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a0feda1f5522522dc50e0c26dcdef71dd">waitPacketSent</a> (uint16_t timeout)</td></tr>
<tr class="separator:a0feda1f5522522dc50e0c26dcdef71dd inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a8ed545cecc22196a325333dc9637e4cf">waitAvailableTimeout</a> (uint16_t timeout)</td></tr>
<tr class="separator:a8ed545cecc22196a325333dc9637e4cf inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5e8f15e1e7480899d18c3a21248bb628">setThisAddress</a> (uint8_t thisAddress)</td></tr>
<tr class="separator:a5e8f15e1e7480899d18c3a21248bb628 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a182436232f7a345bca0d1766d242f3fb">setHeaderTo</a> (uint8_t to)</td></tr>
<tr class="separator:a182436232f7a345bca0d1766d242f3fb inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a470e67f4168dec41435dcc0e194202c8">setHeaderFrom</a> (uint8_t from)</td></tr>
<tr class="separator:a470e67f4168dec41435dcc0e194202c8 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a4dd57079264bda98bc89145fe5d2eb8f">setHeaderId</a> (uint8_t id)</td></tr>
<tr class="separator:a4dd57079264bda98bc89145fe5d2eb8f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#acb992b3c5e360e68b67e4843558bcf3b">setHeaderFlags</a> (uint8_t set, uint8_t clear=RH_FLAGS_APPLICATION_SPECIFIC)</td></tr>
<tr class="separator:acb992b3c5e360e68b67e4843558bcf3b inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2791f57538b02a73e7dbe1031048230e">setPromiscuous</a> (bool promiscuous)</td></tr>
<tr class="separator:a2791f57538b02a73e7dbe1031048230e inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a6f49c9fe68354b50988dec435fa8d086">headerTo</a> ()</td></tr>
<tr class="separator:a6f49c9fe68354b50988dec435fa8d086 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a8cf7a972186592c51c6fde034d17ab9f">headerFrom</a> ()</td></tr>
<tr class="separator:a8cf7a972186592c51c6fde034d17ab9f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a81548960bb29a3ac35325c74cd562f45">headerId</a> ()</td></tr>
<tr class="separator:a81548960bb29a3ac35325c74cd562f45 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a056fbd2df558971fe8a1653499a37c63">headerFlags</a> ()</td></tr>
<tr class="separator:a056fbd2df558971fe8a1653499a37c63 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f2ca335d89f5fac1d213c0aea9da2 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#ab04f2ca335d89f5fac1d213c0aea9da2">lastRssi</a> ()</td></tr>
<tr class="separator:ab04f2ca335d89f5fac1d213c0aea9da2 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a> ()</td></tr>
<tr class="separator:a80ff7dfded27279332cf8fa6f15dce74 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c0a94ba6414b5bbab0133c4d74e646"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#aa1c0a94ba6414b5bbab0133c4d74e646">setMode</a> (<a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a> <a class="el" href="classRHGenericDriver.html#a80ff7dfded27279332cf8fa6f15dce74">mode</a>)</td></tr>
<tr class="memdesc:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the operating mode of the transport. <br /></td></tr>
<tr class="separator:aa1c0a94ba6414b5bbab0133c4d74e646 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a0163fb71dc8d0cd86136882886adba7f">rxBad</a> ()</td></tr>
<tr class="separator:a0163fb71dc8d0cd86136882886adba7f inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5f730e644ab1f5f529fdfa82fdb2ed69">rxGood</a> ()</td></tr>
<tr class="separator:a5f730e644ab1f5f529fdfa82fdb2ed69 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a66a408f88a1188a0fab458816cb705f4">txGood</a> ()</td></tr>
<tr class="separator:a66a408f88a1188a0fab458816cb705f4 inherit pub_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3a837677e78ea04f8ef28951f4954f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a3a837677e78ea04f8ef28951f4954f17">handleInterrupt</a> ()</td></tr>
<tr class="separator:a3a837677e78ea04f8ef28951f4954f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9194768e6717331146b996a057563433"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9194768e6717331146b996a057563433">readFifo</a> ()</td></tr>
<tr class="separator:a9194768e6717331146b996a057563433"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab442ccc43196778c23be4710f78661cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab442ccc43196778c23be4710f78661cc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#ab442ccc43196778c23be4710f78661cc">isr0</a> ()</td></tr>
<tr class="memdesc:ab442ccc43196778c23be4710f78661cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for RF69 connected to interrupt 0. <br /></td></tr>
<tr class="separator:ab442ccc43196778c23be4710f78661cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a3b433e331c5e601fb84f1680efb52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9a3b433e331c5e601fb84f1680efb52"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#ad9a3b433e331c5e601fb84f1680efb52">isr1</a> ()</td></tr>
<tr class="memdesc:ad9a3b433e331c5e601fb84f1680efb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for RF69 connected to interrupt 1. <br /></td></tr>
<tr class="separator:ad9a3b433e331c5e601fb84f1680efb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a358695504b16fe0476a4fd45462d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a358695504b16fe0476a4fd45462d4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a21a358695504b16fe0476a4fd45462d4">isr2</a> ()</td></tr>
<tr class="memdesc:a21a358695504b16fe0476a4fd45462d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for RF69 connected to interrupt 1. <br /></td></tr>
<tr class="separator:a21a358695504b16fe0476a4fd45462d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4b76e598635a0d31d9ff80fc014ffe3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b76e598635a0d31d9ff80fc014ffe3e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a4b76e598635a0d31d9ff80fc014ffe3e">_interruptPin</a></td></tr>
<tr class="memdesc:a4b76e598635a0d31d9ff80fc014ffe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The configured interrupt pin connected to this instance. <br /></td></tr>
<tr class="separator:a4b76e598635a0d31d9ff80fc014ffe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5dee71ee7b0a4f2822e75ace791e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a5dee71ee7b0a4f2822e75ace791e7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a77a5dee71ee7b0a4f2822e75ace791e7">_idleMode</a></td></tr>
<tr class="memdesc:a77a5dee71ee7b0a4f2822e75ace791e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The radio OP mode to use when mode is RHModeIdle. <br /></td></tr>
<tr class="separator:a77a5dee71ee7b0a4f2822e75ace791e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add335b00401894955206adc22a3868d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add335b00401894955206adc22a3868d8"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#add335b00401894955206adc22a3868d8">_deviceType</a></td></tr>
<tr class="memdesc:add335b00401894955206adc22a3868d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reported device type. <br /></td></tr>
<tr class="separator:add335b00401894955206adc22a3868d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebef507d3d9d7bc9cef6b0978d529bd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebef507d3d9d7bc9cef6b0978d529bd6"></a>
int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#aebef507d3d9d7bc9cef6b0978d529bd6">_power</a></td></tr>
<tr class="memdesc:aebef507d3d9d7bc9cef6b0978d529bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The selected output power in dBm. <br /></td></tr>
<tr class="separator:aebef507d3d9d7bc9cef6b0978d529bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb9f21b6825245efd26aef59f5a4916"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb9f21b6825245efd26aef59f5a4916"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#abdb9f21b6825245efd26aef59f5a4916">_bufLen</a></td></tr>
<tr class="memdesc:abdb9f21b6825245efd26aef59f5a4916"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message length in _buf. <br /></td></tr>
<tr class="separator:abdb9f21b6825245efd26aef59f5a4916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acced2755127f9d2dd176902f199a14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9acced2755127f9d2dd176902f199a14"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a9acced2755127f9d2dd176902f199a14">_buf</a> [RH_RF69_MAX_MESSAGE_LEN]</td></tr>
<tr class="memdesc:a9acced2755127f9d2dd176902f199a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of octets of teh last received message or the next to transmit message. <br /></td></tr>
<tr class="separator:a9acced2755127f9d2dd176902f199a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c64477b23a3a1910ead7a71ad1dd4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c64477b23a3a1910ead7a71ad1dd4a"></a>
volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#af9c64477b23a3a1910ead7a71ad1dd4a">_rxBufValid</a></td></tr>
<tr class="memdesc:af9c64477b23a3a1910ead7a71ad1dd4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True when there is a valid message in the Rx buffer. <br /></td></tr>
<tr class="separator:af9c64477b23a3a1910ead7a71ad1dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291827375b652b2ad430fc98f6f563ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291827375b652b2ad430fc98f6f563ec"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a291827375b652b2ad430fc98f6f563ec">_lastPreambleTime</a></td></tr>
<tr class="memdesc:a291827375b652b2ad430fc98f6f563ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time in millis since the last preamble was received (and the last time the RSSI was measured) <br /></td></tr>
<tr class="separator:a291827375b652b2ad430fc98f6f563ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRHSPIDriver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRHSPIDriver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRHSPIDriver.html">RHSPIDriver</a></td></tr>
<tr class="memitem:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9ee8d997815ec209d3208967107ffb1"></a>
<a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">_spi</a></td></tr>
<tr class="memdesc:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the <a class="el" href="classRHGenericSPI.html" title="Base class for SPI interfaces. ">RHGenericSPI</a> instance to use to trasnfer data with teh SPI device. <br /></td></tr>
<tr class="separator:ad9ee8d997815ec209d3208967107ffb1 inherit pro_attribs_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab63525878860cc6ab6c4a994ce704735"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">_slaveSelectPin</a></td></tr>
<tr class="memdesc:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pin number of the Slave Selct pin that is used to select the desired device. <br /></td></tr>
<tr class="separator:ab63525878860cc6ab6c4a994ce704735 inherit pro_attribs_classRHSPIDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324854a5f898b0a48ec83424351730c5"></a>
volatile <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937">RHMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">_mode</a></td></tr>
<tr class="memdesc:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current transport operating mode. <br /></td></tr>
<tr class="separator:a324854a5f898b0a48ec83424351730c5 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d2e9824e29c9d5e9ad28682e53ea974"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a6d2e9824e29c9d5e9ad28682e53ea974">_thisAddress</a></td></tr>
<tr class="memdesc:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">This node id. <br /></td></tr>
<tr class="separator:a6d2e9824e29c9d5e9ad28682e53ea974 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d94c93203714ed3dd9a7434101683e9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2d94c93203714ed3dd9a7434101683e9">_promiscuous</a></td></tr>
<tr class="memdesc:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the transport is in promiscuous mode. <br /></td></tr>
<tr class="separator:a2d94c93203714ed3dd9a7434101683e9 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abff3740bc072a2d435194a7860b2bfe3"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abff3740bc072a2d435194a7860b2bfe3">_rxHeaderTo</a></td></tr>
<tr class="memdesc:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header in the last received mesasge. <br /></td></tr>
<tr class="separator:abff3740bc072a2d435194a7860b2bfe3 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7283cfec4e7c1ecf074307534592fd8f"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a7283cfec4e7c1ecf074307534592fd8f">_rxHeaderFrom</a></td></tr>
<tr class="memdesc:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header in the last received mesasge. <br /></td></tr>
<tr class="separator:a7283cfec4e7c1ecf074307534592fd8f inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3155557c35198acdde0ecdf58a201b19"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a3155557c35198acdde0ecdf58a201b19">_rxHeaderId</a></td></tr>
<tr class="memdesc:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header in the last received mesasge. <br /></td></tr>
<tr class="separator:a3155557c35198acdde0ecdf58a201b19 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd0c3bbc3cfe199924a9e1cb909f5fd"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">_rxHeaderFlags</a></td></tr>
<tr class="memdesc:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header in the last received mesasge. <br /></td></tr>
<tr class="separator:a5fd0c3bbc3cfe199924a9e1cb909f5fd inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759debcdbdb837cea024f777020203e5"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a759debcdbdb837cea024f777020203e5">_txHeaderTo</a></td></tr>
<tr class="memdesc:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">TO header to send in all messages. <br /></td></tr>
<tr class="separator:a759debcdbdb837cea024f777020203e5 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c7cdccccf1b17c73ef95dca6d3075f9"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">_txHeaderFrom</a></td></tr>
<tr class="memdesc:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FROM header to send in all messages. <br /></td></tr>
<tr class="separator:a2c7cdccccf1b17c73ef95dca6d3075f9 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0eafb5a8316b90ad8cd9d42234517da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#ad0eafb5a8316b90ad8cd9d42234517da">_txHeaderId</a></td></tr>
<tr class="memdesc:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID header to send in all messages. <br /></td></tr>
<tr class="separator:ad0eafb5a8316b90ad8cd9d42234517da inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf4db9bddfee361cc44fbf4bd22202bc"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf4db9bddfee361cc44fbf4bd22202bc">_txHeaderFlags</a></td></tr>
<tr class="memdesc:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">FLAGS header to send in all messages. <br /></td></tr>
<tr class="separator:abf4db9bddfee361cc44fbf4bd22202bc inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75ce1fa0448733a6e058f4c7a1ba0a7 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae75ce1fa0448733a6e058f4c7a1ba0a7"></a>
volatile int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#ae75ce1fa0448733a6e058f4c7a1ba0a7">_lastRssi</a></td></tr>
<tr class="memdesc:ae75ce1fa0448733a6e058f4c7a1ba0a7 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the last received RSSI value, in some transport specific units. <br /></td></tr>
<tr class="separator:ae75ce1fa0448733a6e058f4c7a1ba0a7 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bafd8dc638309a473367c4ff8e59c0e"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a3bafd8dc638309a473367c4ff8e59c0e">_rxBad</a></td></tr>
<tr class="memdesc:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (eg bad checksum etc) received. <br /></td></tr>
<tr class="separator:a3bafd8dc638309a473367c4ff8e59c0e inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf09ee8b0cc1bf2b64dc0d963895ff71"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">_rxGood</a></td></tr>
<tr class="memdesc:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of successfully transmitted messaged. <br /></td></tr>
<tr class="separator:abf09ee8b0cc1bf2b64dc0d963895ff71 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f71653ad58e35ddca7fe3e052674ca2"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a5f71653ad58e35ddca7fe3e052674ca2">_txGood</a></td></tr>
<tr class="memdesc:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of the number of bad messages (correct checksum etc) received. <br /></td></tr>
<tr class="separator:a5f71653ad58e35ddca7fe3e052674ca2 inherit pro_attribs_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a18c4172624e59ac174c5b2f940baeea1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18c4172624e59ac174c5b2f940baeea1"></a>
static <a class="el" href="classRH__RF69.html">RH_RF69</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a18c4172624e59ac174c5b2f940baeea1">_deviceForInterrupt</a> [] = {0, 0, 0}</td></tr>
<tr class="memdesc:a18c4172624e59ac174c5b2f940baeea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instances connected to interrupts 0 and 1. <br /></td></tr>
<tr class="separator:a18c4172624e59ac174c5b2f940baeea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdcd185b72c6c37bcab4e80f25c7a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cdcd185b72c6c37bcab4e80f25c7a93"></a>
static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRH__RF69.html#a4cdcd185b72c6c37bcab4e80f25c7a93">_interruptCount</a> = 0</td></tr>
<tr class="memdesc:a4cdcd185b72c6c37bcab4e80f25c7a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of next interrupt number to use in _deviceForInterrupt. <br /></td></tr>
<tr class="separator:a4cdcd185b72c6c37bcab4e80f25c7a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classRHGenericDriver"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classRHGenericDriver')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classRHGenericDriver.html">RHGenericDriver</a></td></tr>
<tr class="memitem:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_classRHGenericDriver"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRHGenericDriver.html#a63915f6420833eb8ec61ee3b0610e34b">printBuffer</a> (const char *prompt, const uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a63915f6420833eb8ec61ee3b0610e34b inherit pub_static_methods_classRHGenericDriver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transceiver. </p>
<p>Works with</p><ul>
<li>the excellent Moteino and Moteino-USB boards from LowPowerLab <a href="http://lowpowerlab.com/moteino/">http://lowpowerlab.com/moteino/</a></li>
<li>compatible chips and modules such as RFM69W, RFM69HW, RFM69CW, RFM69HCW (Semtech SX1231, SX1231H),</li>
<li>RFM69 modules from <a href="http://www.hoperfusa.com">http://www.hoperfusa.com</a> such as <a href="http://www.hoperfusa.com/details.jsp?pid=145">http://www.hoperfusa.com/details.jsp?pid=145</a></li>
<li>Anarduino MiniWireless -CW and -HW boards <a href="http://www.anarduino.com/miniwireless/">http://www.anarduino.com/miniwireless/</a> including the marvellous high powered MinWireless-HW (with 20dBm output for excellent range)</li>
</ul>
<dl class="section user"><dt>Overview</dt><dd></dd></dl>
<p>This class provides basic functions for sending and receiving unaddressed, unreliable datagrams of arbitrary length to 64 octets per packet.</p>
<p>Manager classes may use this class to implement reliable, addressed datagrams and streams, mesh routers, repeaters, translators etc.</p>
<p>Naturally, for any 2 radios to communicate that must be configured to use the same frequency and modulation scheme.</p>
<p>This Driver provides an object-oriented interface for sending and receiving data messages with Hope-RF RF69B and compatible radio modules, such as the RFM69 module.</p>
<p>The Hope-RF (<a href="http://www.hoperf.com">http://www.hoperf.com</a>) RF69 is a low-cost ISM transceiver chip. It supports FSK, GFSK, OOK over a wide range of frequencies and programmable data rates. It also suports AES encryption of up to 64 octets of payload It is available prepackaged on modules such as the RFM69W. And such modules can be prepacked on processor boards such as the Moteino from LowPowerLabs (which is what we used to develop the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver)</p>
<p>This Driver provides functions for sending and receiving messages of up to 60 octets on any frequency supported by the RF69, in a range of predefined data rates and frequency deviations. Frequency can be set with 61Hz precision to any frequency from 240.0MHz to 960.0MHz. Caution: most modules only support a more limited range of frequencies due to antenna tuning.</p>
<p>Up to 2 RF69B modules can be connected to an Arduino (3 on a Mega), permitting the construction of translators and frequency changers, etc.</p>
<p>The following modulation types are suppported with a range of modem configurations for common data rates and frequency deviations:</p><ul>
<li>GFSK Gaussian Frequency Shift Keying</li>
<li>FSK Frequency Shift Keying</li>
</ul>
<p>Support for other RF69 features such as on-chip temperature measurement, transmitter power control etc is also provided.</p>
<p>Tested on USB-Moteino with arduino-1.0.5 on OpenSuSE 13.1</p>
<dl class="section user"><dt>Packet Format</dt><dd></dd></dl>
<p>All messages sent and received by this <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> Driver conform to this packet format:</p>
<ul>
<li>4 octets PREAMBLE</li>
<li>2 octets SYNC 0x2d, 0xd4 (configurable, so you can use this as a network filter)</li>
<li>1 octet <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> payload length</li>
<li>4 octets HEADER: (TO, FROM, ID, FLAGS)</li>
<li>0 to 60 octets DATA</li>
<li>2 octets CRC computed with CRC16(IBM), computed on HEADER and DATA</li>
</ul>
<p>For technical reasons, the message format is not protocol compatible with the 'HopeRF Radio Transceiver Message Library for Arduino' <a href="http://www.airspayce.com/mikem/arduino/HopeRF">http://www.airspayce.com/mikem/arduino/HopeRF</a> from the same author. Nor is it compatible with messages sent by 'Virtual Wire' <a href="http://www.airspayce.com/mikem/arduino/VirtualWire.pdf">http://www.airspayce.com/mikem/arduino/VirtualWire.pdf</a> also from the same author. Nor is it compatible with messages sent by 'RF22' <a href="http://www.airspayce.com/mikem/arduino/RF22">http://www.airspayce.com/mikem/arduino/RF22</a> also from the same author.</p>
<dl class="section user"><dt>Connecting RFM-69 to Arduino</dt><dd></dd></dl>
<p>We tested with Moteino, which is an Arduino Uno compatible with the RFM69W module on-board. Therefore it needs no connections other than the USB programming connection and an antenna to make it work.</p>
<p>If you have a bare RFM69W that you want to connect to an Arduino, you might use these connections (untested): CAUTION: you must use a 3.3V type Arduino, otherwise you will also need voltage level shifters between the Arduino and the RFM69. CAUTION, you must also ensure you connect an antenna</p>
<div class="fragment"><div class="line">                Arduino      RFM69W</div>
<div class="line">                GND----------GND   (ground in)</div>
<div class="line">                3V3----------3.3V  (3.3V in)</div>
<div class="line">interrupt 0 pin D2-----------DIO0  (interrupt request out)</div>
<div class="line">         SS pin D10----------NSS   (chip select in)</div>
<div class="line">        SCK pin D13----------SCK   (SPI clock in)</div>
<div class="line">       MOSI pin D11----------MOSI  (SPI Data in)</div>
<div class="line">       MISO pin D12----------MISO  (SPI Data out)</div>
</div><!-- fragment --><p>With these connections, you can then use the default constructor <a class="el" href="classRH__RF69.html#a9498f2f50f1fb67d4878cff56f6f2661">RH_RF69()</a>. You can override the default settings for the SS pin and the interrupt in the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> constructor if you wish to connect the slave select SS to other than the normal one for your Arduino (D10 for Diecimila, Uno etc and D53 for Mega) or the interrupt request to other than pin D2 (Caution, different processors have different constraints as to the pins available for interrupts).</p>
<p>If you have a Teensy 3.1 and a compatible RFM69 breakout board, you will need to construct the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> instance like this: </p><div class="fragment"><div class="line"><a class="code" href="classRH__RF69.html">RH_RF69</a> driver(15, 16);</div>
</div><!-- fragment --><p>If you have a MoteinoMEGA <a href="https://lowpowerlab.com/shop/moteinomega">https://lowpowerlab.com/shop/moteinomega</a> with RFM69 on board, you dont need to make any wiring connections (the RFM69 module is soldered onto the MotienoMEGA), but you must initialise the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> constructor like this: </p><div class="fragment"><div class="line"><a class="code" href="classRH__RF69.html">RH_RF69</a> driver(4, 2);</div>
</div><!-- fragment --><p> Make sure you have the MoteinoMEGA core installed in your Arduino hardware folder as described in the documentation for the MoteinoMEGA.</p>
<p>It is possible to have 2 or more radios connected to one Arduino, provided each radio has its own SS and interrupt line (SCK, SDI and SDO are common to all radios)</p>
<p>Caution: on some Arduinos such as the Mega 2560, if you set the slave select pin to be other than the usual SS pin (D53 on Mega 2560), you may need to set the usual SS pin to be an output to force the Arduino into SPI master mode.</p>
<p>Caution: Power supply requirements of the RF69 module may be relevant in some circumstances: RF69 modules are capable of pulling 45mA+ at full power, where Arduino's 3.3V line can give 50mA. You may need to make provision for alternate power supply for the RF69, especially if you wish to use full transmit power, and/or you have other shields demanding power. Inadequate power for the RF69 is likely to cause symptoms such as: -reset's/bootups terminate with "init failed" messages -random termination of communication after 5-30 packets sent/received -"fake ok" state, where initialization passes fluently, but communication doesn't happen -shields hang Arduino boards, especially during the flashing </p><dl class="section user"><dt>Interrupts</dt><dd></dd></dl>
<p>The <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver uses interrupts to react to events in the RF69 module, such as the reception of a new packet, or the completion of transmission of a packet. The <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver interrupt service routine reads status from and writes data to the the RF69 module via the SPI interface. It is very important therefore, that if you are using the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver with another SPI based deviced, that you disable interrupts while you transfer data to and from that other device. Use cli() to disable interrupts and sei() to reenable them.</p>
<dl class="section user"><dt>Memory</dt><dd></dd></dl>
<p>The <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver requires non-trivial amounts of memory. The sample programs above all compile to about 8kbytes each, which will fit in the flash proram memory of most Arduinos. However, the RAM requirements are more critical. Therefore, you should be vary sparing with RAM use in programs that use the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver.</p>
<p>It is often hard to accurately identify when you are hitting RAM limits on Arduino. The symptoms can include:</p><ul>
<li>Mysterious crashes and restarts</li>
<li>Changes in behaviour when seemingly unrelated changes are made (such as adding print() statements)</li>
<li>Hanging</li>
<li>Output from Serial.print() not appearing</li>
</ul>
<dl class="section user"><dt>Automatic Frequency Control (AFC)</dt><dd></dd></dl>
<p>The RF69 module is configured by the <a class="el" href="classRH__RF69.html" title="Driver to send and receive unaddressed, unreliable datagrams via an RF69 and compatible radio transce...">RH_RF69</a> driver to always use AFC.</p>
<dl class="section user"><dt>Transmitter Power</dt><dd></dd></dl>
<p>You can control the transmitter power on the RF69 transceiver with the <a class="el" href="classRH__RF69.html#af6dea90251531a0237c2a4f4f26d2941">RH_RF69::setTxPower()</a> function. The argument can be any of -18 to +13 (for RF69W) or -14 to 20 (for RF69HW) The default is 13. Eg: </p><div class="fragment"><div class="line">driver.<a class="code" href="classRH__RF22.html#ac60d2676f1177e509e7d31df515dfb11">setTxPower</a>(-5);</div>
</div><!-- fragment --><p>We have made some actual power measurements against programmed power for Moteino (with RF69W)</p><ul>
<li>Moteino (with RF69W), USB power</li>
<li>10cm RG58C/U soldered direct to RFM69 module ANT and GND</li>
<li>bnc connecteor</li>
<li>12dB attenuator</li>
<li>BNC-SMA adapter</li>
<li>MiniKits AD8307 HF/VHF Power Head (calibrated against Rohde&amp;Schwartz 806.2020 test set)</li>
<li>Tektronix TDS220 scope to measure the Vout from power head <div class="fragment"><div class="line">Program power           Measured Power</div>
<div class="line">   dBm                         dBm</div>
<div class="line">   -18                         -17</div>
<div class="line">   -16                         -16</div>
<div class="line">   -14                         -14</div>
<div class="line">   -12                         -12</div>
<div class="line">   -10                         -9</div>
<div class="line">   -8                          -7</div>
<div class="line">   -6                          -4</div>
<div class="line">   -4                          -3</div>
<div class="line">   -2                          -2</div>
<div class="line">   0                           0.2</div>
<div class="line">   2                           3</div>
<div class="line">   4                           5</div>
<div class="line">   6                           7</div>
<div class="line">   8                           10</div>
<div class="line">   10                          13</div>
<div class="line">   12                          14</div>
<div class="line">   13                          15</div>
<div class="line">   14                         -51</div>
<div class="line">   20                         -51</div>
</div><!-- fragment --> We have also made some actual power measurements against programmed power for Anarduino MiniWireless with RFM69-HW Anarduino MiniWireless (with RFM69-HW), USB power</li>
<li>10cm RG58C/U soldered direct to RFM69 module ANT and GND</li>
<li>bnc connecteor</li>
<li>2x12dB attenuators</li>
<li>BNC-SMA adapter</li>
<li>MiniKits AD8307 HF/VHF Power Head (calibrated against Rohde&amp;Schwartz 806.2020 test set)</li>
<li>Tektronix TDS220 scope to measure the Vout from power head <div class="fragment"><div class="line">Program power           Measured Power</div>
<div class="line">   dBm                         dBm</div>
<div class="line">   -18                         no measurable output</div>
<div class="line">   0                           no measurable output</div>
<div class="line">   13                          no measurable output</div>
<div class="line">   14                          11</div>
<div class="line">   15                          12</div>
<div class="line">   16                          12.4</div>
<div class="line">   17                          14</div>
<div class="line">   18                          15</div>
<div class="line">   19                          15.8</div>
<div class="line">   20                          17</div>
</div><!-- fragment --> (Caution: we dont claim laboratory accuracy for these measurements) You would not expect to get anywhere near these powers to air with a simple 1/4 wavelength wire antenna. Caution: although the RFM69 appears to have a PC antenna on board, you will get much better power and range even with just a 1/4 wave wire antenna.</li>
</ul>
<dl class="section user"><dt>Performance</dt><dd></dd></dl>
<p>Some simple speed performance tests have been conducted. In general packet transmission rate will be limited by the modulation scheme. Also, if your code does any slow operations like Serial printing it will also limit performance. We disabled any printing in the tests below. We tested with <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf" title="GFSK, Whitening, Rb = 250kbs, Fd = 250kHz. ">RH_RF69::GFSK_Rb250Fd250</a>, which is probably the fastest scheme available. We tested with a 13 octet message length, over a very short distance of 10cm.</p>
<p>Transmission (no reply) tests with modulation <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf" title="GFSK, Whitening, Rb = 250kbs, Fd = 250kHz. ">RH_RF69::GFSK_Rb250Fd250</a> and a 13 octet message show about 152 messages per second transmitted and received.</p>
<p>Transmit-and-wait-for-a-reply tests with modulation <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf" title="GFSK, Whitening, Rb = 250kbs, Fd = 250kHz. ">RH_RF69::GFSK_Rb250Fd250</a> and a 13 octet message (send and receive) show about 68 round trips per second. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbe">RH_RF69::ModemConfigChoice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choices for <a class="el" href="classRH__RF69.html#a9802bbdd2c814f177d6c54b28851379a">setModemConfig()</a> for a selected subset of common modulation types, and data rates. If you need another configuration, use the register calculator. and call <a class="el" href="classRH__RF69.html#a1000ce6606514e9ba55c4797346ccbcd">setModemRegisters()</a> with your desired settings. These are indexes into MODEM_CONFIG_TABLE. We strongly recommend you use these symbolic definitions and not their integer equivalents: its possible that new values will be introduced in later versions (though we will try to avoid it). CAUTION: some of these configurations do not work corectly and are marked as such. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea23309558997f0821df4c3f26be956937"></a>FSK_Rb2Fd5&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 2kbs, Fd = 5kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea54ea04c0e1141d1ced103e5863965644"></a>FSK_Rb2_4Fd4_8&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 2.4kbs, Fd = 4.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea8e4c27525b3f1456dbfb66e7d93aa6ed"></a>FSK_Rb4_8Fd9_6&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 4.8kbs, Fd = 9.6kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea1a81d7fa8efafe9ecbab6123e9ceaa7a"></a>FSK_Rb9_6Fd19_2&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 9.6kbs, Fd = 19.2kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea5dfccf26330be9d96bce2a1ffdb58c16"></a>FSK_Rb19_2Fd38_4&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 19.2kbs, Fd = 38.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea195259e4a621abcc733742b51b38c672"></a>FSK_Rb38_4Fd76_8&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 38.4kbs, Fd = 76.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea422b9a9238f51d37911c9b3b14a3ca5c"></a>FSK_Rb57_6Fd120&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 57.6kbs, Fd = 120kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeab88d3432cd83fb07b13f993c5951bc52"></a>FSK_Rb125Fd125&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 125kbs, Fd = 125kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea29c7806372c313d8a5c973b92b0de2f5"></a>FSK_Rb250Fd250&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 250kbs, Fd = 250kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeaf6911ff811fb781cfa4abd5e139b0019"></a>FSK_Rb55555Fd50&#160;</td><td class="fielddoc">
<p>FSK, Whitening, Rb = 55555kbs,Fd = 50kHz for RFM69 lib compatibility. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeada06f635ace1b8b431e7ecc2a5415210"></a>GFSK_Rb2Fd5&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 2kbs, Fd = 5kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeadcf4b773bd8573a20915fcfd8a5fe3d6"></a>GFSK_Rb2_4Fd4_8&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 2.4kbs, Fd = 4.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea25d0e93fdd6986cd2e42ada7c3ceedc5"></a>GFSK_Rb4_8Fd9_6&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 4.8kbs, Fd = 9.6kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea6adec83fd6f777aca47298341bfc2e20"></a>GFSK_Rb9_6Fd19_2&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 9.6kbs, Fd = 19.2kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea427ce920e3dcfd0e27ef4ebb7b81ab30"></a>GFSK_Rb19_2Fd38_4&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 19.2kbs, Fd = 38.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea60fb6c655242086be1c38f663907f4f7"></a>GFSK_Rb38_4Fd76_8&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 38.4kbs, Fd = 76.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea0d2b7d4e131c25576f552efa6ce148c4"></a>GFSK_Rb57_6Fd120&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 57.6kbs, Fd = 120kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea20215f43ba81642933be63eaf13ba941"></a>GFSK_Rb125Fd125&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 125kbs, Fd = 125kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf"></a>GFSK_Rb250Fd250&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 250kbs, Fd = 250kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea752e8ffc06f2ea7280ec69839ff980ab"></a>GFSK_Rb55555Fd50&#160;</td><td class="fielddoc">
<p>GFSK, Whitening, Rb = 55555kbs,Fd = 50kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeab29466f7bb837092a1740e5995bcea9a"></a>OOK_Rb1Bw1&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 1kbs, Rx Bandwidth = 1kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeafb854ba28fd990a6a770d2aa7bfcad2f"></a>OOK_Rb1_2Bw75&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 1.2kbs, Rx Bandwidth = 75kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea163016ee033ce11c74d11b0c2b749a8f"></a>OOK_Rb2_4Bw4_8&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 2.4kbs, Rx Bandwidth = 4.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeacd470e1fff2c7e8fb56724cd3f74e97b"></a>OOK_Rb4_8Bw9_6&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 4.8kbs, Rx Bandwidth = 9.6kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea56b3342df10e7203efb04298fe989e63"></a>OOK_Rb9_6Bw19_2&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 9.6kbs, Rx Bandwidth = 19.2kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbea4cb008e46446e1397b8a72128eddff40"></a>OOK_Rb19_2Bw38_4&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 19.2kbs, Rx Bandwidth = 38.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8b7db5c6e4eb542f46fec351b2084bbeae164eaae8c1a2ca5801b4195b1f3a8e4"></a>OOK_Rb32Bw64&#160;</td><td class="fielddoc">
<p>OOK, Whitening, Rb = 32kbs, Rx Bandwidth = 64kHz. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9498f2f50f1fb67d4878cff56f6f2661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RH_RF69::RH_RF69 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em> = <code>SS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interruptPin</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRHGenericSPI.html">RHGenericSPI</a> &amp;&#160;</td>
          <td class="paramname"><em>spi</em> = <code>hardware_spi</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. You can have multiple instances, but each instance must have its own interrupt and slave select pin. After constructing, you must call <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a> to initialise the interface and the radio module. A maximum of 3 instances can co-exist on one processor, provided there are sufficient distinct interrupt lines, one for each instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveSelectPin</td><td>the Arduino pin number of the output to use to select the RF69 before accessing it. Defaults to the normal SS pin for your Arduino (D10 for Diecimila, Uno etc, D53 for Mega, D10 for Maple) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interruptPin</td><td>The interrupt Pin number that is connected to the RF69 DIO0 interrupt line. Defaults to pin 2. Caution: You must specify an interrupt capable pin. On many Arduino boards, there are limitations as to which pins may be used as interrupts. On Leonardo pins 0, 1, 2 or 3. On Mega2560 pins 2, 3, 18, 19, 20, 21. On Due and Teensy, any digital pin. On other Arduinos pins 2 or 3. See <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for more details. On Chipkit Uno32, pins 38, 2, 7, 8, 35. On other boards, any digital pin may be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the SPI interface object to use. Defaults to the standard Arduino hardware SPI interface </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRH__RF69.html#a77a5dee71ee7b0a4f2822e75ace791e7">_idleMode</a>, and <a class="el" href="classRH__RF69.html#a4b76e598635a0d31d9ff80fc014ffe3e">_interruptPin</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6f2584eacf160b9d53605e82b46b6574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the receiver and checks whether a received message is available. This can be called multiple times in a timeout loop </p><dl class="section return"><dt>Returns</dt><dd>true if a complete, valid message has been received and is able to be retrieved by <a class="el" href="classRH__RF69.html#ae298950973257e99d3e958678a26fdf2">recv()</a> </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a2dd522b8eb16c51dc948b4ca4d623888">RHGenericDriver</a>.</p>

<p>References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF69.html#af9c64477b23a3a1910ead7a71ad1dd4a">_rxBufValid</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHGenericDriver::RHModeTx</a>, and <a class="el" href="classRH__RF69.html#a43cfebafbafc3c62dcdba7d5e2591203">setModeRx()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#ae298950973257e99d3e958678a26fdf2">recv()</a>.</p>

</div>
</div>
<a class="anchor" id="a803de96f489599271790bca92ce9436e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RH_RF69::getLastPreambleTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time in millis since the most recent preamble was received, and when the most recent RSSI measurement was made. </p>

</div>
</div>
<a class="anchor" id="a3a837677e78ea04f8ef28951f4954f17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::handleInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a low level function to handle the interrupts for one instance of RF69. Called automatically by isr*() Should not need to be called by user code. </p>

<p>References <a class="el" href="classRH__RF69.html#a291827375b652b2ad430fc98f6f563ec">_lastPreambleTime</a>, <a class="el" href="classRHGenericDriver.html#ae75ce1fa0448733a6e058f4c7a1ba0a7">RHGenericDriver::_lastRssi</a>, <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRHGenericDriver.html#a5f71653ad58e35ddca7fe3e052674ca2">RHGenericDriver::_txGood</a>, <a class="el" href="classRH__RF69.html#a9194768e6717331146b996a057563433">readFifo()</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHGenericDriver::RHModeRx</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHGenericDriver::RHModeTx</a>, <a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle()</a>, and <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#ab442ccc43196778c23be4710f78661cc">isr0()</a>, <a class="el" href="classRH__RF69.html#ad9a3b433e331c5e601fb84f1680efb52">isr1()</a>, and <a class="el" href="classRH__RF69.html#a21a358695504b16fe0476a4fd45462d4">isr2()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d78af6f999adf187861e7e3f1d52e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises this instance and the radio module connected to it. The following steps are taken:</p><ul>
<li>Initialise the slave select pin and the SPI interface library</li>
<li>Checks the connected RF69 module can be communicated</li>
<li>Attaches an interrupt handler</li>
<li>Configures the RF69 module</li>
<li>Sets the frequency to 434.0 MHz</li>
<li>Sets the modem data rate to FSK_Rb2Fd5 <dl class="section return"><dt>Returns</dt><dd>true if everything was successful </dd></dl>
</li>
</ul>

<p>Reimplemented from <a class="el" href="classRHGenericDriver.html#a3e1cfcd4d6187702c364cf4c81e76365">RHGenericDriver</a>.</p>

<p>References <a class="el" href="classRH__RF69.html#a18c4172624e59ac174c5b2f940baeea1">_deviceForInterrupt</a>, <a class="el" href="classRH__RF69.html#add335b00401894955206adc22a3868d8">_deviceType</a>, <a class="el" href="classRH__RF69.html#a4cdcd185b72c6c37bcab4e80f25c7a93">_interruptCount</a>, <a class="el" href="classRH__RF69.html#a4b76e598635a0d31d9ff80fc014ffe3e">_interruptPin</a>, <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf">GFSK_Rb250Fd250</a>, <a class="el" href="classRHSPIDriver.html#a7ba5e6fc53e02ff8125218bc296b4557">RHSPIDriver::init()</a>, <a class="el" href="classRH__RF69.html#ab442ccc43196778c23be4710f78661cc">isr0()</a>, <a class="el" href="classRH__RF69.html#ad9a3b433e331c5e601fb84f1680efb52">isr1()</a>, <a class="el" href="classRH__RF69.html#a21a358695504b16fe0476a4fd45462d4">isr2()</a>, <a class="el" href="classRH__RF69.html#a3dc02a05e8f2ec61210d62fe53673ca9">setEncryptionKey()</a>, <a class="el" href="classRH__RF69.html#aa46952d56856f22f9319fd64e3001675">setFrequency()</a>, <a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle()</a>, <a class="el" href="classRH__RF69.html#a9802bbdd2c814f177d6c54b28851379a">setModemConfig()</a>, <a class="el" href="classRH__RF69.html#a9e72900d5511c694d8510ab60d99917d">setPreambleLength()</a>, <a class="el" href="classRH__RF69.html#aeadfa5f2783c821de73ecb09c50000d4">setSyncWords()</a>, <a class="el" href="classRH__RF69.html#af6dea90251531a0237c2a4f4f26d2941">setTxPower()</a>, <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3285a31a83a6ab471f149efc7bbd206"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RH_RF69::maxMessageLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum message length supported by this driver </p><dl class="section return"><dt>Returns</dt><dd>The maximum message length supported by this driver </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a267459de4eb3032c5efb8b220af7d164">RHGenericDriver</a>.</p>

</div>
</div>
<a class="anchor" id="aa09f8182eea13623f2fee4059d13d6f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::printRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the value of a single register to the Serial device if RH_HAVE_SERIAL is defined for the current platform For debugging/testing only </p><dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p>References <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#abf5be102f9291447f22b6df823455aea">printRegisters()</a>.</p>

</div>
</div>
<a class="anchor" id="abf5be102f9291447f22b6df823455aea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::printRegisters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the value of all the RF69 registers to the Serial device if RH_HAVE_SERIAL is defined for the current platform For debugging/testing only </p><dl class="section return"><dt>Returns</dt><dd>true if successful </dd></dl>

<p>References <a class="el" href="classRH__RF69.html#aa09f8182eea13623f2fee4059d13d6f7">printRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="a9194768e6717331146b996a057563433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::readFifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Low level function to read the FIFO and put the received data into the receive buffer Should not need to be called by user code. </p>

<p>References <a class="el" href="classRH__RF69.html#a9acced2755127f9d2dd176902f199a14">_buf</a>, <a class="el" href="classRH__RF69.html#abdb9f21b6825245efd26aef59f5a4916">_bufLen</a>, <a class="el" href="classRHGenericDriver.html#a2d94c93203714ed3dd9a7434101683e9">RHGenericDriver::_promiscuous</a>, <a class="el" href="classRH__RF69.html#af9c64477b23a3a1910ead7a71ad1dd4a">_rxBufValid</a>, <a class="el" href="classRHGenericDriver.html#abf09ee8b0cc1bf2b64dc0d963895ff71">RHGenericDriver::_rxGood</a>, <a class="el" href="classRHGenericDriver.html#a5fd0c3bbc3cfe199924a9e1cb909f5fd">RHGenericDriver::_rxHeaderFlags</a>, <a class="el" href="classRHGenericDriver.html#a7283cfec4e7c1ecf074307534592fd8f">RHGenericDriver::_rxHeaderFrom</a>, <a class="el" href="classRHGenericDriver.html#a3155557c35198acdde0ecdf58a201b19">RHGenericDriver::_rxHeaderId</a>, <a class="el" href="classRHGenericDriver.html#abff3740bc072a2d435194a7860b2bfe3">RHGenericDriver::_rxHeaderTo</a>, <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, <a class="el" href="classRHGenericDriver.html#a6d2e9824e29c9d5e9ad28682e53ea974">RHGenericDriver::_thisAddress</a>, and <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a3a837677e78ea04f8ef28951f4954f17">handleInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="ae298950973257e99d3e958678a26fdf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::recv </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the receiver on if it not already on. If there is a valid message available, copy it to buf and return true else return false. If a message is copied, *len is set to the length (Caution, 0 length messages are permitted). You should be sure to call this function frequently enough to not miss any messages It is recommended that you call it in your main loop. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy the received message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pointer to available space in buf. Set to the actual number of octets copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid message was copied to buf </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a58f0f64dff770bbeb1b197a5fca0579a">RHGenericDriver</a>.</p>

<p>References <a class="el" href="classRH__RF69.html#a9acced2755127f9d2dd176902f199a14">_buf</a>, <a class="el" href="classRH__RF69.html#abdb9f21b6825245efd26aef59f5a4916">_bufLen</a>, <a class="el" href="classRH__RF69.html#af9c64477b23a3a1910ead7a71ad1dd4a">_rxBufValid</a>, and <a class="el" href="classRH__RF69.html#a6f2584eacf160b9d53605e82b46b6574">available()</a>.</p>

</div>
</div>
<a class="anchor" id="a90d8979ae35033ac8bc813302e203173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RH_RF69::rssiRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and returns the current RSSI value. Causes the current signal strength to be measured and returned If you want to find the RSSI of the last received message, use <a class="el" href="classRHGenericDriver.html#ab04f2ca335d89f5fac1d213c0aea9da2">lastRssi()</a> instead. </p><dl class="section return"><dt>Returns</dt><dd>The current RSSI value on units of 0.5dB. </dd></dl>

<p>References <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a995470e009100f30b6945747d67e9a4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits until any previous transmit packet is finished being transmitted with <a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">waitPacketSent()</a>. Then loads a message into the transmitter and starts the transmitter. Note that a message length of 0 is NOT permitted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes of data to send (&gt; 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message length was valid and it was correctly queued for transmit </dd></dl>

<p>Implements <a class="el" href="classRHGenericDriver.html#a5716069edea652af8019daaeb64357ee">RHGenericDriver</a>.</p>

<p>References <a class="el" href="classRHSPIDriver.html#ab63525878860cc6ab6c4a994ce704735">RHSPIDriver::_slaveSelectPin</a>, <a class="el" href="classRHSPIDriver.html#ad9ee8d997815ec209d3208967107ffb1">RHSPIDriver::_spi</a>, <a class="el" href="classRHGenericDriver.html#abf4db9bddfee361cc44fbf4bd22202bc">RHGenericDriver::_txHeaderFlags</a>, <a class="el" href="classRHGenericDriver.html#a2c7cdccccf1b17c73ef95dca6d3075f9">RHGenericDriver::_txHeaderFrom</a>, <a class="el" href="classRHGenericDriver.html#ad0eafb5a8316b90ad8cd9d42234517da">RHGenericDriver::_txHeaderId</a>, <a class="el" href="classRHGenericDriver.html#a759debcdbdb837cea024f777020203e5">RHGenericDriver::_txHeaderTo</a>, <a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle()</a>, <a class="el" href="classRH__RF69.html#a8e4a5d2f1847063b5f7cf6a2d14e246a">setModeTx()</a>, <a class="el" href="classRHGenericSPI.html#a14bc6f8954d9d68c0a56319444ffdd24">RHGenericSPI::transfer()</a>, and <a class="el" href="classRHGenericDriver.html#a7506f47e9a391ffa05f7271950c26ffe">RHGenericDriver::waitPacketSent()</a>.</p>

</div>
</div>
<a class="anchor" id="a3dc02a05e8f2ec61210d62fe53673ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setEncryptionKey </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables AES encryption and sets the AES encryption key, used to encrypt and decrypt all messages. The default is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to use. Must be 16 bytes long. The same key must be installed in other instances of RF69, otherwise communications will not work correctly. If key is NULL, encryption is disabled. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRHSPIDriver.html#a559b2c489825fe1ae737cb4371956d3d">RHSPIDriver::spiBurstWrite()</a>, <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="aa46952d56856f22f9319fd64e3001675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>afcPullInRange</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter and receiver centre frequency </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">centre</td><td>Frequency in MHz. 240.0 to 960.0. Caution, RF69 comes in several different frequency ranges, and setting a frequency outside that range of your radio will probably not work </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">afcPullInRange</td><td>Not used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the selected frquency centre is within range </dd></dl>

<p>References <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a5efc7d09d32f024ecd983c4e53e37dcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setIdleMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idleMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the radio operating mode for the case when the driver is idle (ie not transmitting or receiving), allowing you to control the idle mode power requirements at the expense of slower transitions to transmit and receive modes. By default, the idle mode is RH_RF69_OPMODE_MODE_STDBY, but eg setIdleMode(RH_RF69_OPMODE_MODE_SLEEP) will provide a much lower idle current but slower transitions. Call this function after <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idleMode</td><td>The chip operating mode to use when the driver is idle. One of RH_RF69_OPMODE_* </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRH__RF69.html#a77a5dee71ee7b0a4f2822e75ace791e7">_idleMode</a>.</p>

</div>
</div>
<a class="anchor" id="af66bfbf2057f1faeba0ad75007d623ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setModeIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Tx changes it to Idle. If the transmitter or receiver is running, disables them. </p>

<p>References <a class="el" href="classRH__RF69.html#a77a5dee71ee7b0a4f2822e75ace791e7">_idleMode</a>, <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF69.html#aebef507d3d9d7bc9cef6b0978d529bd6">_power</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a09daae373d8c5f63419be869c99f8d66">RHGenericDriver::RHModeIdle</a>, <a class="el" href="classRH__RF69.html#a890c2d3ed4d1954a67f7cc190349b2ab">setOpMode()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a3a837677e78ea04f8ef28951f4954f17">handleInterrupt()</a>, <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>, and <a class="el" href="classRH__RF69.html#a995470e009100f30b6945747d67e9a4c">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a9802bbdd2c814f177d6c54b28851379a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::setModemConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbe">ModemConfigChoice</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select one of the predefined modem configurations. If you need a modem configuration not provided here, use <a class="el" href="classRH__RF69.html#a1000ce6606514e9ba55c4797346ccbcd">setModemRegisters()</a> with your own <a class="el" href="structRH__RF69_1_1ModemConfig.html" title="Defines register values for a set of modem configuration registers. ">ModemConfig</a>. The default after <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a> is <a class="el" href="classRH__RF69.html#a8b7db5c6e4eb542f46fec351b2084bbea6ccb1433d0075f901dbdf9ea5e2b69bf" title="GFSK, Whitening, Rb = 250kbs, Fd = 250kHz. ">RH_RF69::GFSK_Rb250Fd250</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The configuration choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is a valid choice. </dd></dl>

<p>References <a class="el" href="classRH__RF69.html#a1000ce6606514e9ba55c4797346ccbcd">setModemRegisters()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a1000ce6606514e9ba55c4797346ccbcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setModemRegisters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRH__RF69_1_1ModemConfig.html">ModemConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all the registers required to configure the data modem in the RF69, including the data rate, bandwidths etc. You can use this to configure the modem with custom configurations if none of the canned configurations in ModemConfigChoice suit you. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="structRH__RF69_1_1ModemConfig.html" title="Defines register values for a set of modem configuration registers. ">ModemConfig</a> structure containing values for the modem configuration registers. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structRH__RF69_1_1ModemConfig.html#a0dbef3c4c10835523fc9d3325df4a949">RH_RF69::ModemConfig::reg_02</a>, <a class="el" href="structRH__RF69_1_1ModemConfig.html#a1a86c7520169dc4e48f510dcecc350fe">RH_RF69::ModemConfig::reg_19</a>, <a class="el" href="structRH__RF69_1_1ModemConfig.html#abeeda3c6ec35c3cf9783f849c2a9ca65">RH_RF69::ModemConfig::reg_37</a>, <a class="el" href="classRHSPIDriver.html#a559b2c489825fe1ae737cb4371956d3d">RHSPIDriver::spiBurstWrite()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a9802bbdd2c814f177d6c54b28851379a">setModemConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="a43cfebafbafc3c62dcdba7d5e2591203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setModeRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Tx or Idle, changes it to Rx. Starts the receiver in the RF69. </p>

<p>References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF69.html#aebef507d3d9d7bc9cef6b0978d529bd6">_power</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a37e9e88e825d4ec7728c421e3a32e490">RHGenericDriver::RHModeRx</a>, <a class="el" href="classRH__RF69.html#a890c2d3ed4d1954a67f7cc190349b2ab">setOpMode()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a6f2584eacf160b9d53605e82b46b6574">available()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e4a5d2f1847063b5f7cf6a2d14e246a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setModeTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Idle, changes it to Rx. F Starts the transmitter in the RF69. </p>

<p>References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRH__RF69.html#aebef507d3d9d7bc9cef6b0978d529bd6">_power</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a2f830e2667843de407766fe33500713c">RHGenericDriver::RHModeTx</a>, <a class="el" href="classRH__RF69.html#a890c2d3ed4d1954a67f7cc190349b2ab">setOpMode()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a995470e009100f30b6945747d67e9a4c">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a890c2d3ed4d1954a67f7cc190349b2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setOpMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the parameters for the RF69 OPMODE. This is a low level device access function, and should not normally ned to be used by user code. Instead can use stModeRx(), <a class="el" href="classRH__RF69.html#a8e4a5d2f1847063b5f7cf6a2d14e246a">setModeTx()</a>, <a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>RF69 OPMODE to set, one of RH_RF69_OPMODE_MODE_*. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#af66bfbf2057f1faeba0ad75007d623ec">setModeIdle()</a>, <a class="el" href="classRH__RF69.html#a43cfebafbafc3c62dcdba7d5e2591203">setModeRx()</a>, and <a class="el" href="classRH__RF69.html#a8e4a5d2f1847063b5f7cf6a2d14e246a">setModeTx()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e72900d5511c694d8510ab60d99917d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the length of the preamble in bytes. Caution: this should be set to the same value on all nodes in your network. Default is 4. Sets the message preamble length in REG_0?_PREAMBLE?SB </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Preamble length in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="aeadfa5f2783c821de73ecb09c50000d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setSyncWords </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>syncWords</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sync words for transmit and receive Caution: SyncWords should be set to the same value on all nodes in your network. Nodes with different SyncWords set will never receive each others messages, so different SyncWords can be used to isolate different networks from each other. Default is { 0x2d, 0xd4 }. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">syncWords</td><td>Array of sync words, 1 to 4 octets long. NULL if no sync words to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of sync words to set, 1 to 4. 0 if no sync words to be used. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRHSPIDriver.html#a559b2c489825fe1ae737cb4371956d3d">RHSPIDriver::spiBurstWrite()</a>, <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="af6dea90251531a0237c2a4f4f26d2941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RH_RF69::setTxPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter power output level. Be a good neighbour and set the lowest power level you need. Caution: legal power limits may apply in certain countries. After <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>, the power will be set to 13dBm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>Transmitter power level in dBm. For RF69W, valid values are from -18 to +13 (higher power settings disable the transmitter). For RF69HW, valid values are from +14 to +20. Caution: at +20dBm, duty cycle is limited to 1% and a maximum VSWR of 3:1 at the antenna port. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRH__RF69.html#aebef507d3d9d7bc9cef6b0978d529bd6">_power</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRH__RF69.html#a0d78af6f999adf187861e7e3f1d52e99">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b91f0d505957e62bc8f7bf4167d6772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RH_RF69::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the radio into low-power sleep mode. If successful, the transport will stay in sleep mode until woken by changing mode it idle, transmit or receive (eg by calling <a class="el" href="classRH__RF69.html#a995470e009100f30b6945747d67e9a4c">send()</a>, <a class="el" href="classRH__RF69.html#ae298950973257e99d3e958678a26fdf2">recv()</a>, <a class="el" href="classRH__RF69.html#a6f2584eacf160b9d53605e82b46b6574">available()</a> etc) Caution: there is a time penalty as the radio takes a finite time to wake from sleep mode. </p><dl class="section return"><dt>Returns</dt><dd>true if sleep mode was successfully entered. </dd></dl>

<p>Reimplemented from <a class="el" href="classRHGenericDriver.html#a97050555cbf46ad723ad9c45d7f76a55">RHGenericDriver</a>.</p>

<p>References <a class="el" href="classRHGenericDriver.html#a324854a5f898b0a48ec83424351730c5">RHGenericDriver::_mode</a>, <a class="el" href="classRHGenericDriver.html#a7c96558708f18937bc2fa7341f217937a39cb96e8e2d40d5a4137f99c9d98d01b">RHGenericDriver::RHModeSleep</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a864eae13e51279b9bca9de3fb2a062f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RH_RF69::temperatureRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the on-chip temperature sensor. The RF69 must be in Idle mode (= RF69 Standby) to measure temperature. The measurement is uncalibrated and without calibration, you can expect it to be far from correct. </p><dl class="section return"><dt>Returns</dt><dd>The measured temperature, in degrees C from -40 to 85 (uncalibrated) </dd></dl>

<p>References <a class="el" href="classRHSPIDriver.html#a275b8c3d4d27a59d8f93a036b17bbf22">RHSPIDriver::spiRead()</a>, and <a class="el" href="classRHSPIDriver.html#a649210bd63262e23c9becabfc7142fd3">RHSPIDriver::spiWrite()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RH__RF69_8h_source.html">RH_RF69.h</a></li>
<li>RH_RF69.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
